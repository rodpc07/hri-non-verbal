#include <moveit/move_group_interface/move_group_interface.h>
#include <moveit/planning_scene_interface/planning_scene_interface.h>
#include <moveit/planning_interface/planning_interface.h>

#include <moveit_msgs/DisplayRobotState.h>
#include <moveit_msgs/DisplayTrajectory.h>

#include <moveit_msgs/AttachedCollisionObject.h>
#include <moveit_msgs/CollisionObject.h>

#include <moveit_visual_tools/moveit_visual_tools.h>

#include <visualization_msgs/Marker.h>
#include <interactive_markers/interactive_marker_server.h>

#include <moveit/robot_state/robot_state.h>
#include <moveit/planning_scene_monitor/planning_scene_monitor.h>
#include <moveit/kinematic_constraints/utils.h>
#include <moveit/planning_pipeline/planning_pipeline.h>
#include <moveit/robot_state/conversions.h>

#include <moveit_grasps/two_finger_grasp_generator.h>
#include <moveit_grasps/two_finger_grasp_data.h>
#include <moveit_grasps/two_finger_grasp_filter.h>
#include <moveit_grasps/grasp_planner.h>

#include <iostream>
#include <string>

#include <memory>

using namespace std;

const double tau = 2 * M_PI;

namespace moveit_grasps_demo
{
    static const std::string LOGNAME = "grasp_pipeline_demo";

    namespace
    {
        bool isStateValid(const planning_scene::PlanningScene *planning_scene,
                          const moveit_visual_tools::MoveItVisualToolsPtr &visual_tools, robot_state::RobotState *robot_state,
                          const robot_model::JointModelGroup *group, const double *ik_solution)
        {
            robot_state->setJointGroupPositions(group, ik_solution);
            robot_state->update();
            return !planning_scene->isStateColliding(*robot_state, group->getName());
        }

        void waitForNextStep(const moveit_visual_tools::MoveItVisualToolsPtr &visual_tools, const std::string &prompt)
        {
            visual_tools->prompt(prompt);
        }

    } // namespace

    class GraspPipelineDemo
    {
    public:
        // Constructor
        GraspPipelineDemo(std::shared_ptr<moveit::planning_interface::MoveGroupInterface> arm_mgi,
                          std::shared_ptr<moveit::planning_interface::MoveGroupInterface> gripper_mgi,
                          std::string arm_planning_group_name,
                          std::shared_ptr<moveit_visual_tools::MoveItVisualTools> visual_tools)
            : nh_("~"), arm_mgi_(arm_mgi), gripper_mgi_(gripper_mgi), visual_tools_(visual_tools)
        {
            arm_jmg_ = arm_mgi_->getCurrentState()->getJointModelGroup(arm_planning_group_name);
            // Get arm info from param server
            planning_group_name_ = arm_jmg_->getName();
            ee_group_name_ = gripper_mgi->getName();

            loadScene();
            setupGraspPipeline();
        }

        void loadScene()
        {
            ROS_INFO("LOAD_SCENE");
            // ---------------------------------------------------------------------------------------------
            // Load planning scene to share
            planning_scene_monitor_ = std::make_shared<planning_scene_monitor::PlanningSceneMonitor>("robot_description");
            if (!planning_scene_monitor_->getPlanningScene())
            {
                ROS_ERROR_STREAM_NAMED(LOGNAME, "Planning scene not configured");
                return;
            }
            planning_scene_monitor_->startPublishingPlanningScene(planning_scene_monitor::PlanningSceneMonitor::UPDATE_SCENE,
                                                                  "grasping_planning_scene");
            planning_scene_monitor_->getPlanningScene()->setName("grasping_planning_scene");

            // ---------------------------------------------------------------------------------------------

            visual_tools_->setPlanningSceneMonitor(planning_scene_monitor_);
            visual_tools_->loadMarkerPub();
            visual_tools_->loadRobotStatePub("/display_robot_state");
            visual_tools_->loadTrajectoryPub("/display_planned_path");
            visual_tools_->loadSharedRobotState();
            *visual_tools_->getSharedRobotState() = *arm_mgi_->getCurrentState();
            visual_tools_->enableBatchPublishing();
            visual_tools_->deleteAllMarkers();
            visual_tools_->removeAllCollisionObjects();
            visual_tools_->hideRobot();
            visual_tools_->trigger();

            // Publish the global frame
            visual_tools_->publishAxis(Eigen::Isometry3d::Identity());
            visual_tools_->trigger();
        }

        void setupGraspPipeline()
        {
            // ---------------------------------------------------------------------------------------------
            // Load grasp data specific to our robot
            ROS_INFO("setupGraspPipeline");
            grasp_data_ =
                std::make_shared<moveit_grasps::TwoFingerGraspData>(nh_, ee_group_name_, visual_tools_->getRobotModel());
            if (!grasp_data_->loadGraspData(nh_, ee_group_name_))
            {
                ROS_ERROR_STREAM_NAMED(LOGNAME, "Failed to load Grasp Data parameters.");
                exit(-1);
            }

            // ---------------------------------------------------------------------------------------------
            // Load grasp generator
            grasp_generator_ = std::make_shared<moveit_grasps::TwoFingerGraspGenerator>(visual_tools_);

            // Set the ideal grasp orientation for scoring
            std::vector<double> ideal_grasp_rpy = {3.14, 0.0, 0.0};
            grasp_generator_->setIdealTCPGraspPoseRPY(ideal_grasp_rpy);

            // Set custom grasp score weights
            auto grasp_score_weights = std::make_shared<moveit_grasps::TwoFingerGraspScoreWeights>();
            grasp_score_weights->orientation_x_score_weight_ = 2.0;
            grasp_score_weights->orientation_y_score_weight_ = 2.0;
            grasp_score_weights->orientation_z_score_weight_ = 2.0;
            grasp_score_weights->translation_x_score_weight_ = 1.0;
            grasp_score_weights->translation_y_score_weight_ = 1.0;
            grasp_score_weights->translation_z_score_weight_ = 1.0;
            // Finger gripper specific weights.
            grasp_score_weights->depth_score_weight_ = 2.0;
            grasp_score_weights->width_score_weight_ = 2.0;
            // Assign the grasp score weights in the grasp_generator
            grasp_generator_->setGraspScoreWeights(grasp_score_weights);

            // ---------------------------------------------------------------------------------------------
            // Load grasp filter
            grasp_filter_ = std::make_shared<moveit_grasps::TwoFingerGraspFilter>(visual_tools_->getSharedRobotState(), visual_tools_);
            // ---------------------------------------------------------------------------------------------
            // Load grasp planner for approach, lift and retreat planning
            grasp_planner_ = std::make_shared<moveit_grasps::GraspPlanner>(visual_tools_);

            // MoveIt Grasps allows for a manual breakpoint debugging tool to be optionally passed in
            grasp_planner_->setWaitForNextStepCallback(boost::bind(&waitForNextStep, visual_tools_, _1));

            // -----------------------------------------------------
            // Load the motion planning pipeline
            planning_pipeline_ =
                std::make_shared<planning_pipeline::PlanningPipeline>(arm_mgi_->getRobotModel(), nh_, "planning_plugin", "request_adapter");
        }

        bool demoRandomGrasp()
        {
            ROS_INFO("demoRandomGrasp");
            // -----------------------------------
            // Generate random object to grasp
            geometry_msgs::Pose object_pose;
            double object_x_depth;
            double object_y_width;
            double object_z_height;
            std::string object_name;
            if (!generateRandomCuboid(object_name, object_pose, object_x_depth, object_y_width, object_z_height))
            {
                ROS_ERROR_NAMED(LOGNAME, "Failed to add random cuboid ot planning scene");
                return false;
            }

            // -----------------------------------
            // Generate grasp candidates
            std::vector<moveit_grasps::GraspCandidatePtr> grasp_candidates;

            // Configure the desired types of grasps
            moveit_grasps::TwoFingerGraspCandidateConfig grasp_generator_config =
                moveit_grasps::TwoFingerGraspCandidateConfig();
            grasp_generator_config.disableAll();
            grasp_generator_config.enable_face_grasps_ = true;
            grasp_generator_config.generate_y_axis_grasps_ = true;
            grasp_generator_config.generate_x_axis_grasps_ = true;
            grasp_generator_config.generate_z_axis_grasps_ = true;
            grasp_generator_config.enable_variable_angle_grasps_ = true;

            grasp_generator_->setGraspCandidateConfig(grasp_generator_config);
            if (!grasp_generator_->generateGrasps(visual_tools_->convertPose(object_pose), object_x_depth, object_y_width,
                                                  object_z_height, grasp_data_, grasp_candidates))
            {
                ROS_ERROR_NAMED(LOGNAME, "Grasp generator failed to generate any valid grasps");
                return false;
            }

            // --------------------------------------------
            // Generating a seed state for filtering grasps
            ROS_INFO("DEGUB - 2");
            visual_tools_->prompt("2");

            robot_state::RobotStatePtr seed_state = std::make_shared<robot_state::RobotState>(*visual_tools_->getSharedRobotState());

            Eigen::Isometry3d eef_mount_grasp_pose = visual_tools_->convertPose(object_pose) * grasp_data_->tcp_to_eef_mount_.inverse();
            if (!getIKSolution(arm_jmg_, eef_mount_grasp_pose, *seed_state, grasp_data_->parent_link_->getName()))
            {
                ROS_WARN_STREAM_NAMED(LOGNAME, "The ideal seed state is not reachable. Using start state as seed.");
            }
            visual_tools_->prompt("3");

            // --------------------------------------------
            // Filtering grasps
            // Note: This step also solves for the grasp and pre-grasp states and stores them in grasp candidates)
            bool filter_pregrasps = true;
            if (!grasp_filter_->filterGrasps(grasp_candidates, planning_scene_monitor_, arm_jmg_, seed_state, filter_pregrasps,
                                             object_name))
            {
                ROS_ERROR_STREAM_NAMED(LOGNAME, "Filter grasps failed");
                return false;
            }
            if (!grasp_filter_->removeInvalidAndFilter(grasp_candidates))
            {
                ROS_WARN_NAMED(LOGNAME, "Grasp filtering removed all grasps");
                return false;
            }
            ROS_INFO_STREAM_NAMED(LOGNAME, "" << grasp_candidates.size() << " remain after filtering");
            ROS_INFO("DEGUB - 3");

            visual_tools_->prompt("4");

            // Plan free-space approach, cartesian approach, lift and retreat trajectories
            moveit_grasps::GraspCandidatePtr selected_grasp_candidate;
            moveit_msgs::MotionPlanResponse pre_approach_plan;

            if (!planFullGrasp(grasp_candidates, selected_grasp_candidate, pre_approach_plan, object_name))
            {
                ROS_ERROR_STREAM_NAMED(LOGNAME, "Failed to plan grasp motions");
                return false;
            }
            ROS_INFO("DEGUB - 4");

            visualizePick(selected_grasp_candidate, pre_approach_plan);

            return true;
        }

        void visualizePick(const moveit_grasps::GraspCandidatePtr &valid_grasp_candidate,
                           const moveit_msgs::MotionPlanResponse &pre_approach_plan)
        {
            ROS_INFO("visualizePick");
            EigenSTL::vector_Isometry3d waypoints;
            moveit_grasps::GraspGenerator::getGraspWaypoints(valid_grasp_candidate, waypoints);

            // Visualize waypoints
            visual_tools_->publishAxisLabeled(waypoints[0], "pregrasp");
            visual_tools_->publishAxisLabeled(waypoints[1], "grasp");
            visual_tools_->publishAxisLabeled(waypoints[2], "lifted");
            visual_tools_->publishAxisLabeled(waypoints[3], "retreat");
            visual_tools_->trigger();

            // Get the pre and post grasp states
            visual_tools_->prompt("pre_grasp");
            robot_state::RobotStatePtr pre_grasp_state =
                std::make_shared<robot_state::RobotState>(*visual_tools_->getSharedRobotState());
            valid_grasp_candidate->getPreGraspState(pre_grasp_state);
            visual_tools_->publishRobotState(pre_grasp_state, rviz_visual_tools::ORANGE);
            robot_state::RobotStatePtr grasp_state =
                std::make_shared<robot_state::RobotState>(*visual_tools_->getSharedRobotState());
            if (valid_grasp_candidate->getGraspStateClosed(grasp_state))
            {
                visual_tools_->prompt("grasp");
                visual_tools_->publishRobotState(grasp_state, rviz_visual_tools::YELLOW);
            }
            if (valid_grasp_candidate->segmented_cartesian_traj_.size() > 1 &&
                valid_grasp_candidate->segmented_cartesian_traj_[1].size())
            {
                visual_tools_->prompt("lift");
                visual_tools_->publishRobotState(valid_grasp_candidate->segmented_cartesian_traj_[1].back(),
                                                 rviz_visual_tools::BLUE);
            }
            if (valid_grasp_candidate->segmented_cartesian_traj_.size() > 2 &&
                valid_grasp_candidate->segmented_cartesian_traj_[2].size())
            {
                visual_tools_->prompt("retreat");
                visual_tools_->publishRobotState(valid_grasp_candidate->segmented_cartesian_traj_[2].back(),
                                                 rviz_visual_tools::PURPLE);
            }

            visual_tools_->prompt("show free space approach");
            visual_tools_->hideRobot();
            visual_tools_->trigger();

            bool wait_for_animation = true;
            visual_tools_->publishTrajectoryPath(pre_approach_plan.trajectory, pre_grasp_state, wait_for_animation);
            ros::Duration(0.25).sleep();
            if (valid_grasp_candidate->segmented_cartesian_traj_.size() > moveit_grasps::APPROACH)
                visual_tools_->publishTrajectoryPath(valid_grasp_candidate->segmented_cartesian_traj_[moveit_grasps::APPROACH],
                                                     valid_grasp_candidate->grasp_data_->arm_jmg_, wait_for_animation);
            ros::Duration(0.25).sleep();

            if (valid_grasp_candidate->segmented_cartesian_traj_.size() > moveit_grasps::LIFT)
                visual_tools_->publishTrajectoryPath(valid_grasp_candidate->segmented_cartesian_traj_[moveit_grasps::LIFT],
                                                     valid_grasp_candidate->grasp_data_->arm_jmg_, wait_for_animation);
            ros::Duration(0.25).sleep();

            if (valid_grasp_candidate->segmented_cartesian_traj_.size() > moveit_grasps::RETREAT)
                visual_tools_->publishTrajectoryPath(valid_grasp_candidate->segmented_cartesian_traj_[moveit_grasps::RETREAT],
                                                     valid_grasp_candidate->grasp_data_->arm_jmg_, wait_for_animation);
            ros::Duration(0.25).sleep();
        }

        bool planFullGrasp(std::vector<moveit_grasps::GraspCandidatePtr> &grasp_candidates,
                           moveit_grasps::GraspCandidatePtr &valid_grasp_candidate,
                           moveit_msgs::MotionPlanResponse &pre_approach_plan, const std::string &object_name)
        {
            ROS_INFO("planFullGrasp");
            moveit::core::RobotStatePtr current_state;
            {
                boost::scoped_ptr<planning_scene_monitor::LockedPlanningSceneRW> ls(
                    new planning_scene_monitor::LockedPlanningSceneRW(planning_scene_monitor_));
                current_state = std::make_shared<robot_state::RobotState>((*ls)->getCurrentState());
            }

            bool success = false;
            for (; !grasp_candidates.empty(); grasp_candidates.erase(grasp_candidates.begin()))
            {
                valid_grasp_candidate = grasp_candidates.front();
                valid_grasp_candidate->getPreGraspState(current_state);
                if (!grasp_planner_->planApproachLiftRetreat(valid_grasp_candidate, current_state, planning_scene_monitor_, false,
                                                             object_name))
                {
                    ROS_INFO_NAMED(LOGNAME, "failed to plan approach lift retreat");
                    continue;
                }

                robot_state::RobotStatePtr pre_grasp_state =
                    valid_grasp_candidate->segmented_cartesian_traj_[moveit_grasps::APPROACH].front();
                if (!planPreApproach(*pre_grasp_state, pre_approach_plan))
                {
                    ROS_WARN_NAMED(LOGNAME, "failed to plan to pregrasp_state");
                    continue;
                }

                success = true;
                break;
            }
            return success;
        }

        bool planPreApproach(const robot_state::RobotState &goal_state, moveit_msgs::MotionPlanResponse &pre_approach_plan)
        {
            ROS_INFO("planPreApproach");
            planning_interface::MotionPlanRequest req;
            planning_interface::MotionPlanResponse res;

            double tolerance_above = 0.01;
            double tolerance_below = 0.01;
            // req.planner_id = "RRTConnectkConfigDefault";
            req.group_name = arm_jmg_->getName();
            req.num_planning_attempts = 5;
            req.allowed_planning_time = 1.5;
            moveit_msgs::Constraints goal =
                kinematic_constraints::constructGoalConstraints(goal_state, arm_jmg_, tolerance_below, tolerance_above);

            req.goal_constraints.push_back(goal);
            boost::scoped_ptr<planning_scene_monitor::LockedPlanningSceneRW> ls(
                new planning_scene_monitor::LockedPlanningSceneRW(planning_scene_monitor_));

            // ---------------------------------
            // Change the robot current state
            // NOTE: We have to do this since Panda start configuration is in self collision.
            robot_state::RobotState rs = (*ls)->getCurrentState();

            robot_state::robotStateToRobotStateMsg(rs, req.start_state);
            // ---------------------------

            planning_pipeline_->generatePlan(*ls, req, res);
            if (res.error_code_.val != res.error_code_.SUCCESS)
            {
                ROS_INFO_NAMED(LOGNAME, "Failed to plan approach successfully");
                return false;
            }

            res.getMessage(pre_approach_plan);
            return true;
        }

        bool getIKSolution(const moveit::core::JointModelGroup *arm_jmg, const Eigen::Isometry3d &target_pose,
                           robot_state::RobotState &solution, const std::string &link_name)
        {
            ROS_INFO("getIKSolution");
            boost::scoped_ptr<planning_scene_monitor::LockedPlanningSceneRW> ls(
                new planning_scene_monitor::LockedPlanningSceneRW(planning_scene_monitor_));

            moveit::core::GroupStateValidityCallbackFn constraint_fn = boost::bind(
                &isStateValid, static_cast<const planning_scene::PlanningSceneConstPtr &>(*ls).get(), visual_tools_, _1, _2, _3);

            // seed IK call with current state
            solution = (*ls)->getCurrentState();

            // Solve IK problem for arm
            // disable explicit restarts to guarantee close solution if one exists
            const double timeout = 0.1;
            return solution.setFromIK(arm_jmg, target_pose, link_name, timeout, constraint_fn);
        }

        bool generateRandomCuboid(std::string &object_name, geometry_msgs::Pose &object_pose, double &x_depth,
                                  double &y_width, double &z_height)
        {

            // Generate random cuboid
            double xmin = 0.5;
            double xmax = 0.7;
            double ymin = -0.25;
            double ymax = 0.25;
            double zmin = 0.2;
            double zmax = 0.7;
            rviz_visual_tools::RandomPoseBounds pose_bounds(xmin, xmax, ymin, ymax, zmin, zmax);

            double cuboid_size_min = 0.01;
            double cuboid_size_max = 0.03;
            rviz_visual_tools::RandomCuboidBounds cuboid_bounds(cuboid_size_min, cuboid_size_max);

            object_name = "pick_target";
            visual_tools_->generateRandomCuboid(object_pose, x_depth, y_width, z_height, pose_bounds, cuboid_bounds);
            visual_tools_->publishCollisionCuboid(object_pose, x_depth, y_width, z_height, object_name, rviz_visual_tools::RED);
            visual_tools_->publishAxis(object_pose, rviz_visual_tools::MEDIUM);
            visual_tools_->trigger();

            bool success = true;
            double timeout = 5; // seconds
            ros::Rate rate(100);
            while (success && !planning_scene_monitor_->getPlanningScene()->knowsFrameTransform(object_name))
            {
                rate.sleep();
                success = rate.cycleTime().toSec() < timeout;
            }
            return success;
        }

    private:
        // A shared node handle
        ros::NodeHandle nh_;

        // Tool for visualizing things in Rviz
        moveit_visual_tools::MoveItVisualToolsPtr visual_tools_;

        // MoveIt! Grasps
        moveit_grasps::TwoFingerGraspGeneratorPtr grasp_generator_;

        // Robot-specific data for generating grasps
        moveit_grasps::TwoFingerGraspDataPtr grasp_data_;

        // For planning approach and retreats
        moveit_grasps::GraspPlannerPtr grasp_planner_;

        // For selecting good grasps
        moveit_grasps::TwoFingerGraspFilterPtr grasp_filter_;

        // Shared planning scene (load once for everything)
        planning_scene_monitor::PlanningSceneMonitorPtr planning_scene_monitor_;

        std::shared_ptr<moveit::planning_interface::MoveGroupInterface> arm_mgi_;
        const moveit::core::JointModelGroup *arm_jmg_;
        std::shared_ptr<moveit::planning_interface::MoveGroupInterface> gripper_mgi_;

        // All the motion planning components
        planning_pipeline::PlanningPipelinePtr planning_pipeline_;

        // Choose which arm to use
        std::string ee_group_name_;
        std::string planning_group_name_;

    }; // end of class

} // namespace moveit_grasps_demo

int main(int argc, char **argv)
{
    ros::init(argc, argv, "pick_and_place");
    ros::NodeHandle node_handle;
    ros::AsyncSpinner spinner(1);
    spinner.start();

    auto planning_scene_interface = std::make_shared<moveit::planning_interface::PlanningSceneInterface>();

    auto both_arms_mgi = std::make_shared<moveit::planning_interface::MoveGroupInterface>("both_arms");
    const moveit::core::JointModelGroup *both_arms_jmg = both_arms_mgi->getCurrentState()->getJointModelGroup("both_arms");

    auto right_arm_mgi = std::make_shared<moveit::planning_interface::MoveGroupInterface>("right_arm");
    const moveit::core::JointModelGroup *right_arm_jmg = right_arm_mgi->getCurrentState()->getJointModelGroup("right_arm");

    auto left_arm_mgi = std::make_shared<moveit::planning_interface::MoveGroupInterface>("left_arm");
    const moveit::core::JointModelGroup *left_arm_jmg = left_arm_mgi->getCurrentState()->getJointModelGroup("left_arm");

    auto right_gripper_mgi = std::make_shared<moveit::planning_interface::MoveGroupInterface>("right_gripper");
    const moveit::core::JointModelGroup *right_gripper_jmg = right_gripper_mgi->getCurrentState()->getJointModelGroup("right_gripper");

    auto left_gripper_mgi = std::make_shared<moveit::planning_interface::MoveGroupInterface>("left_gripper");
    const moveit::core::JointModelGroup *left_gripper_jmg = left_gripper_mgi->getCurrentState()->getJointModelGroup("left_gripper");

    right_arm_mgi->setMaxVelocityScalingFactor(1.0);
    right_arm_mgi->setMaxAccelerationScalingFactor(1.0);
    right_gripper_mgi->setMaxVelocityScalingFactor(1.0);
    right_gripper_mgi->setMaxAccelerationScalingFactor(1.0);

    left_arm_mgi->setMaxVelocityScalingFactor(1.0);
    left_arm_mgi->setMaxAccelerationScalingFactor(1.0);
    left_gripper_mgi->setMaxVelocityScalingFactor(1.0);
    left_gripper_mgi->setMaxAccelerationScalingFactor(1.0);

    namespace rvt = rviz_visual_tools;
    auto visual_tools = std::make_shared<moveit_visual_tools::MoveItVisualTools>("yumi_base_link");
    visual_tools->deleteAllMarkers();
    visual_tools->loadRemoteControl();

    // RViz provides many types of markers, in this demo we will use text, cylinders, and spheres
    Eigen::Isometry3d text_pose = Eigen::Isometry3d::Identity();
    text_pose.translation().z() = 0.75;
    visual_tools->publishText(text_pose, "PICK AND PLACE TESTING", rvt::WHITE, rvt::XXLARGE);
    visual_tools->trigger();

    moveit_grasps_demo::GraspPipelineDemo tester(both_arms_mgi, right_gripper_mgi, "right_arm", visual_tools);
    tester.demoRandomGrasp();

    ros::shutdown();
    return 0;
}