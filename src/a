class HRI_Interface
{
public:
    HRI_Interface(moveit::planning_interface::MoveGroupInterface *move_group_interface, moveit_visual_tools::MoveItVisualTools *visual_tools, moveit::core::JointModelGroup *joint_model_group)
        : move_group_interface_(move_group_interface), visual_tools_(visual_tools), joint_model_group_(joint_model_group)
    {
    }

    void yes_no()
    {
        // Set constraints for arm pose
        moveit_msgs::Constraints path_constraints;
        // Add joint constraints
        moveit_msgs::JointConstraint joint_constraint;

        joint_constraint.joint_name = move_group_interface_->getActiveJoints().at(0) // "yumi_joint_1_r"
                                      joint_constraint.position = 125 * (M_PI / 180);
        joint_constraint.tolerance_above = 0.2;
        joint_constraint.tolerance_below = 0.2;
        path_constraints.joint_constraints.push_back(joint_constraint);

        joint_constraint.joint_name = move_group_interface_->getActiveJoints().at(1); // "yumi_joint_2_r"
        joint_constraint.position = -115 * (M_PI / 180);
        joint_constraint.tolerance_above = 0.1;
        joint_constraint.tolerance_below = 0.1;
        path_constraints.joint_constraints.push_back(joint_constraint);

        joint_constraint.joint_name = move_group_interface_->getActiveJoints().at(3); // "yumi_joint_3_r"
        joint_constraint.position = 45 * (M_PI / 180);
        joint_constraint.tolerance_above = 0.2;
        joint_constraint.tolerance_below = 0.2;
        path_constraints.joint_constraints.push_back(joint_constraint);
        // Set the path constraints for the goal
        move_group_interface_->setPathConstraints(path_constraints);
        move_group_interface_->setGoalPositionTolerance(0.1);

        // The eef's final pose will always be upright and about 0.4 units high.
        geometry_msgs::Pose final_pose;
        final_pose.position.z = 0.40;
        final_pose.orientation.x = 0;
        final_pose.orientation.y = 0;
        final_pose.orientation.z = 0;
        final_pose.orientation.w = 1;

        tf2_ros::Buffer tfBuffer;
        tf2_ros::TransformListener listener(tfBuffer);
        geometry_msgs::TransformStamped transformStamped;
        try
        {
            transformStamped = tfBuffer.lookupTransform("my_marker", "yumi_link_1_r", ros::Time(0), ros::Duration(5));
        }
        catch (tf2::TransformException ex)
        {
            ROS_ERROR("%s", ex.what());
            ros::Duration(1.0).sleep();
        }

        double dist_ratio = 0.4 / sqrt(pow(transformStamped.transform.translation.x, 2) + pow(transformStamped.transform.translation.y, 2));

        // Multiply dist_ratio to x and y values
        double transformed_x = transformStamped.transform.translation.x * dist_ratio;
        double transformed_y = transformStamped.transform.translation.y * dist_ratio;

        geometry_msgs::PoseStamped poseStamped_arm_referenced;
        poseStamped_arm_referenced.header.stamp = ros::Time::now();
        poseStamped_arm_referenced.header.frame_id = "my_marker";
        poseStamped_arm_referenced.pose.position.x = transformed_x;
        poseStamped_arm_referenced.pose.position.y = transformed_y;
        poseStamped_arm_referenced.pose.position.z = 0.0; // Assuming the z-coordinate remains the same

        geometry_msgs::PoseStamped poseStamped_base_referenced = tfBuffer.transform(poseStamped_arm_referenced, "yumi_base_link");

        final_pose.position.x = poseStamped_base_referenced.pose.position.x;
        final_pose.position.y = poseStamped_base_referenced.pose.position.y;

        move_group_interface_->setPoseTarget(final_pose);

        moveit::planning_interface::MoveGroupInterface::Plan plan;

        bool success = (move_group_interface_->plan(plan) == moveit::planning_interface::MoveItErrorCode::SUCCESS);
        // visual_tools_->deleteAllMarkers();
        // visual_tools_->publishTrajectoryPath(plan.trajectory_, plan.start_state_, true);
        // visual_tools_->trigger();

        move_group_interface_->move();
        move_group_interface_->clearPathConstraints();
    }

    void screw_unscrew()
    {
        moveit::core::RobotStatePtr current_state = move_group_interface_->getCurrentState();

        std::vector<double> joint_group_positions;
        current_state->copyJointGroupPositions(&joint_model_group, joint_group_positions);

        joint_group_positions.back() = joint_model_group;
        move_group_interface_->setJointValueTarget(joint_group_positions);

        moveit::planning_interface::MoveGroupInterface::Plan my_plan;

        bool success = (move_group_interface_->plan(my_plan) == moveit::core::MoveItErrorCode::SUCCESS);
        ROS_INFO_NAMED("tutorial", "Visualizing plan 2 (joint space goal) %s", success ? "" : "FAILED");

        move_group_interface_->clearPathConstraints();

        // Translate EndEffector Backwards
        geometry_msgs::Pose start_end_effector_pose = move_group_interface_->getCurrentPose().pose;
        Eigen::Isometry3d goal_end_effector_eigen;
        geometry_msgs::Pose goal_end_effector_pose = start_end_effector_pose;

        std::vector<geometry_msgs::Pose> waypoints;

        double turn_angle = M_PI_2;

        for (double angle = 0; angle <= 2 * M_PI; angle += turn_angle)
        {
            // Translation
            visual_tools_->convertPoseSafe(goal_end_effector_pose, goal_end_effector_eigen);
            goal_end_effector_eigen.translate(Eigen::Vector3d(0, 0, -0.0125));
            goal_end_effector_pose = visual_tools_->convertPose(goal_end_effector_eigen);

            // Rotation
            tf2::Quaternion q_orig, q_rot, q_new;
            tf2::convert(goal_end_effector_pose.orientation, q_orig);
            q_rot.setRPY(0, 0, -M_PI_2);
            q_new = q_orig * q_rot;
            geometry_msgs::Quaternion rotated_quat;
            tf2::convert(q_new, rotated_quat);
            goal_end_effector_pose.orientation = rotated_quat;

            waypoints.push_back(goal_end_effector_pose);
        }

        moveit_msgs::RobotTrajectory trajectory;
        const double jump_threshold = 0.0;
        const double eef_step = 0.05;
        double fraction = move_group_interface_->computeCartesianPath(waypoints, eef_step, jump_threshold, trajectory);

        for (std::size_t i = 0; i < waypoints.size(); ++i)
            visual_tools_->publishAxis(waypoints[i]);
        visual_tools_->trigger();

        move_group_interface_->execute(trajectory);
        move_group_interface_->clearPathConstraints();
    }

private:
    moveit::planning_interface::MoveGroupInterface *move_group_interface_;
    moveit_visual_tools::MoveItVisualTools *visual_tools_;
    const moveit::core::JointModelGroup *joint_model_group_;
};